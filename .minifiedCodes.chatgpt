<"file: src\commands.js">const vscode = require("vscode");const path = require("path");const fs = require("fs");const Minifier = require("./minifier");const { getFiles, normalizeIgnorePath } = require("./fileUtils");function registerCommands(context) {context.subscriptions.push(vscode.commands.registerCommand("extension.minifyFiles", minifyFilesCommand),vscode.commands.registerCommand("extension.obfuscateCurrentJSFile", obfuscateCurrentJSFileCommand),vscode.commands.registerCommand("extension.obfuscateAllJSInWorkspace", obfuscateAllJSInWorkspaceCommand),vscode.commands.registerCommand("extension.minifySelected", minifySelectedCommand));}const CUSTOM_IGNORE_KEY = 'minifierCustomIgnoreList';async function minifyFilesCommand() {const workspaceFolder = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : (await vscode.window.showOpenDialog({canSelectFiles: false,canSelectFolders: true,canSelectMany: false,openLabel: "Select Folder"}))[0];if (!workspaceFolder) return;// Retrieve the previous custom ignore listconst context = vscode.workspace.getConfiguration('minifier');const previousIgnoreList = context.get(CUSTOM_IGNORE_KEY, []);const options = await vscode.window.showQuickPick([{ label: "Ignore files starting by . (dot)?", value: "dot" },{ label: 'Ignore files ending in "min.css" and "min.js"?', value: "min", picked: true },{ label: "Ignore any other file or folder?", value: "other" },...(previousIgnoreList.length > 0 ? [{ label: "Use previous custom ignore list", value: "previous" }] : [])], {canPickMany: true,placeHolder: "Select options to ignore (use checkboxes)"});const ignoreDotFiles = options ? options.some(option => option.value === "dot") : false;const ignoreOther = options ? options.some(option => option.value === "other") : false;const ignoreMinFiles = options ? options.some(option => option.value === "min") : false;const usePreviousIgnoreList = options ? options.some(option => option.value === "previous") : false;let ignoreList = [];if (usePreviousIgnoreList) {ignoreList = previousIgnoreList;} else if (ignoreOther) {const input = await vscode.window.showInputBox({prompt: "Enter the file or folder names, extensions, or paths to ignore, separated by commas (e.g., .json, .txt, src/components)"});if (input) {ignoreList = input.split(",").map(item => normalizeIgnorePath(item.trim())).filter(item => item);// Save the new ignore listawait context.update(CUSTOM_IGNORE_KEY, ignoreList, vscode.ConfigurationTarget.Global);}}const rootPath = workspaceFolder.fsPath;const outputPath = path.join(rootPath, ".minifiedCodes.chatgpt");const files = getFiles(rootPath, rootPath, ignoreList, ignoreDotFiles, ignoreMinFiles);const minifier = new Minifier(files, outputPath);try {await minifier.minifyFiles();if (fs.existsSync(outputPath)) {try {const document = await vscode.workspace.openTextDocument(outputPath);await vscode.window.showTextDocument(document, vscode.ViewColumn.Active);vscode.window.showInformationMessage(`Minification completed. Output file: ${outputPath}`);} catch (openError) {vscode.window.showWarningMessage(`Minification completed, but couldn't open the output file. It's located at: ${outputPath}`);}} else {vscode.window.showWarningMessage(`Minification process completed, but the output file was not found at ${outputPath}`);}} catch (error) {vscode.window.showErrorMessage(`An error occurred during minification: ${error.message}`);return;}const obfuscationOption = await vscode.window.showQuickPick([{ label: "Obfuscate current JS file", value: "current" },{ label: "Obfuscate all JS in the workspace", value: "all" },],{ placeHolder: "Select an obfuscation option" });const jsFiles = files.filter((file) => file.extension === "js");if (obfuscationOption && obfuscationOption.value) {if (obfuscationOption.value === "current") {const activeTextEditor = vscode.window.activeTextEditor;if (activeTextEditor) {const activeDocument = activeTextEditor.document;const activeFile = jsFiles.find((file) => file.path === path.relative(rootPath, activeDocument.uri.fsPath));if (activeFile) {try {await minifier.obfuscateJsFiles([activeFile]);vscode.window.showInformationMessage(`Current JS file obfuscated successfully.`);} catch (obfuscateError) {vscode.window.showErrorMessage(`Error obfuscating current JS file: ${obfuscateError.message}`);}} else {vscode.window.showWarningMessage(`Current file is not a JavaScript file or was not included in the minification process.`);}} else {vscode.window.showWarningMessage(`No active text editor found.`);}} else if (obfuscationOption.value === "all") {try {await minifier.obfuscateJsFiles(jsFiles);vscode.window.showInformationMessage(`All JS files in the workspace obfuscated successfully.`);} catch (obfuscateError) {vscode.window.showErrorMessage(`Error obfuscating JS files: ${obfuscateError.message}`);}}}}async function obfuscateCurrentJSFileCommand() {const workspaceFolder = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : (await vscode.window.showOpenDialog({canSelectFiles: false,canSelectFolders: true,canSelectMany: false,openLabel: "Select Folder"}))[0];if (!workspaceFolder) return;const rootPath = workspaceFolder.fsPath;const outputPath = path.join(rootPath, ".minifiedCodes.chatgpt");const files = getFiles(rootPath, rootPath, [], false, false);const minifier = new Minifier(files, outputPath);const activeTextEditor = vscode.window.activeTextEditor;if (activeTextEditor) {const activeDocument = activeTextEditor.document;const activeFile = files.find((file) => file.path === path.relative(rootPath, activeDocument.uri.fsPath) && file.extension === "js");if (activeFile) {await minifier.obfuscateJsFiles([activeFile]);}}}async function obfuscateAllJSInWorkspaceCommand() {const workspaceFolder = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : (await vscode.window.showOpenDialog({canSelectFiles: false,canSelectFolders: true,canSelectMany: false,openLabel: "Select Folder"}))[0];if (!workspaceFolder) return;const rootPath = workspaceFolder.fsPath;const outputPath = path.join(rootPath, ".minifiedCodes.chatgpt");const files = getFiles(rootPath, rootPath, [], false, false);const minifier = new Minifier(files, outputPath);const jsFiles = files.filter((file) => file.extension === "js");await minifier.obfuscateJsFiles(jsFiles);}async function minifySelectedCommand(uri, uris) {let selectedUris = uris;if (!selectedUris) {selectedUris = uri ? [uri] : [];}if (selectedUris.length === 0) {vscode.window.showErrorMessage("No files or folders selected.");return;}const workspaceFolder = vscode.workspace.getWorkspaceFolder(selectedUris[0]);if (!workspaceFolder) {vscode.window.showErrorMessage("Unable to determine workspace folder.");return;}const rootPath = workspaceFolder.uri.fsPath;const outputPath = path.join(rootPath, ".minifiedCodes.chatgpt");const allFiles = [];for (const selectedUri of selectedUris) {const selectedPath = selectedUri.fsPath;if (fs.statSync(selectedPath).isDirectory()) {allFiles.push(...getFiles(rootPath, selectedPath, [], false, false));} else {const relativePath = path.relative(rootPath, selectedPath);let extension = path.extname(selectedPath).substring(1);if (path.basename(selectedPath).endsWith('.blade.php')) {extension = 'blade.php';}allFiles.push({path: relativePath,name: path.basename(selectedPath),extension: extension,modifiedTime: fs.statSync(selectedPath).mtime});}}const minifier = new Minifier(allFiles, outputPath);await minifier.minifyFiles();const document = await vscode.workspace.openTextDocument(outputPath);await vscode.window.showTextDocument(document, vscode.ViewColumn.Active);vscode.window.showInformationMessage(`Minified ${allFiles.length} files from ${selectedUris.length} selections.`);}module.exports = {registerCommands};</"file: src\commands.js">

<"file: src\fileUtils.js">const fs = require("fs");const path = require("path");function normalizeIgnorePath(ignorePath) {// Convert Windows backslashes to forward slashesignorePath = ignorePath.replace(/\\/g, '/');// Remove leading and trailing slashesignorePath = ignorePath.replace(/^\/|\/$/g, '');return ignorePath;}function getFiles(rootPath, currentPath, ignoreList, ignoreDotFiles, ignoreMinFiles) {const files = [];const directoryItems = fs.readdirSync(currentPath);ignoreList = ignoreList.concat(["package-lock.json", "dist", "obj", "bin", ".vscode"]);for (const itemName of directoryItems) {const itemPath = path.join(currentPath, itemName);const relativePath = path.relative(rootPath, itemPath);const normalizedRelativePath = normalizeIgnorePath(relativePath);const itemExtension = path.extname(itemName);if (ignoreList.includes(itemName) ||ignoreList.includes(normalizedRelativePath) ||ignoreList.includes(itemExtension) ||ignoreList.some(ignorePath => normalizedRelativePath.startsWith(ignorePath))) {continue;}const itemStat = fs.statSync(itemPath);if (itemStat.isDirectory()) {if (itemName.startsWith("env_") || itemName === "node_modules" || itemName === ".git" || itemName === "vendor") {continue;}files.push(...getFiles(rootPath, itemPath, ignoreList, ignoreDotFiles, ignoreMinFiles));} else if (itemStat.isFile()) {if ((ignoreDotFiles && itemName.startsWith(".")) || (ignoreMinFiles && (itemExtension === ".min.js" || itemExtension === ".min.css"))) {continue;}let extension = itemExtension.substring(1);if (itemName.endsWith('.blade.php')) {extension = 'blade.php';}files.push({ path: relativePath, name: itemName, extension: extension, modifiedTime: itemStat.mtime });}}return files;}module.exports = {getFiles,normalizeIgnorePath};</"file: src\fileUtils.js">

<"file: package.json">{"name": "code-minifier-for-chatgpt-prompts","version": "0.8.4","description": "ðŸš€ Minify files of a folder into one single file to make it part of ChatGPT Coding Prompts ðŸ§ ","displayName": "Code Minifier for ChatGPT Prompts","publisher": "lmsutools","repository": {"type": "git","url": "https://github.com/lmsutools/code-minifier-for-chatgpt-prompts"},"engines": {"vscode": "^1.45.0"},"keywords": ["minifyFiles","minify","prompts","Prompter","openai","natural language processing","NLP","ChatGPT Coding","javascript obfuscate","javascript obfuscator","js obfuscator"],"activationEvents": ["onCommand:extension.minifyFiles","onCommand:extension.minifySelected"],"main": "./src/extension.js","author": "A ChatGPT Prompter","icon": "images/icon.png","license": "MIT","dependencies": {"clean-css": "^4.2.3","glob": "^9.3.2","html-minifier": "^3.5.21","javascript-obfuscator": "^4.0.2","minify-xml": "^4.0.0","minimatch": "^7.4.3","strip-json-comments": "^5.0.0","terser": "^5.16.9","uglify-js": "^3.9.2","xml-minifier": "^1.0.1"},"contributes": {"commands": [{"command": "extension.minifyFiles","title": "Code Minifier for ChatGPT Prompts"},{"command": "extension.obfuscateCurrentJSFile","title": "Obfuscate current JS file"},{"command": "extension.obfuscateAllJSInWorkspace","title": "Obfuscate all JS in the workspace"},{"command": "extension.minifySelected","title": "Minify Selected for ChatGPT"}],"menus": {"explorer/context": [{"command": "extension.minifySelected","group": "YourExtensionGroup@1","when": "explorerViewletVisible && filesExplorerFocus && !explorerResourceIsRoot"}]}}}</"file: package.json">

<"file: src\minifier.js">const fs = require("fs");const path = require("path");const htmlMinifier = require("html-minifier").minify;const JavaScriptObfuscator = require("javascript-obfuscator");class Minifier {constructor(files, outputFilePath) {this.files = files;this.outputFilePath = outputFilePath;this.errors = [];}async obfuscateJsFiles(filesToObfuscate) {const obfuscationResults = [];for (const file of filesToObfuscate) {const filePath = path.join(this.outputFilePath, "..", file.path);try {const fileContent = fs.readFileSync(filePath, "utf-8");const obfuscatedCode = JavaScriptObfuscator.obfuscate(fileContent);fs.writeFileSync(filePath, obfuscatedCode.getObfuscatedCode());obfuscationResults.push(`<"file: ${file.path}">Successfully obfuscated</"file: ${file.path}">`);} catch (error) {obfuscationResults.push(`<"file: ${file.path}">Couldn't be obfuscated: ${error.message}</"file: ${file.path}">`);}}fs.writeFileSync(path.join(this.outputFilePath, "..", "obfuscated.txt"), obfuscationResults.join("\n"));}shouldIgnoreFile(fileName, ignoreList) {return ignoreList.some((ignoreItem) => fileName.endsWith(ignoreItem));}customMinify(content) {return content.split("\n").map((line) => line.trim()).join("");}minifyXAML(content) {return content.replace(/\s*\n\s*/g, "").replace(/\s*\>\s*/g, ">").replace(/\s*\</g, "<").replace(/\s+/g, " ");}minifyCSharpCode(content) {return content.replace(/\/\/.*/g, "").replace(/\/\*[\s\S]*?\*\//g, "").replace(/\n/g, "").replace(/\s+/g, " ").replace(/\s*([;,:{}()])\s*/g, "$1");}minifyPHP(content) {// Remove commentscontent = content.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');// Remove whitespacecontent = content.replace(/\s+/g, ' ');// Remove whitespace around PHP tagscontent = content.replace(/\s*<\?php\s*/g, '<?php ');content = content.replace(/\s*\?>\s*/g, '?>');return content;}async minifyFiles() {this.files.sort((a, b) => b.modifiedTime - a.modifiedTime);if (fs.existsSync(this.outputFilePath)) {fs.unlinkSync(this.outputFilePath);}await Promise.all(this.files.map(async (file) => {if (this.shouldIgnoreFile(file.name, ["package-lock.json", "dist", "obj", "bin", ".vscode", ".png", ".jpg", ".sample", ".lock", ".md", ".babelrc", ".vsix", ".vscodeignore"])) {return;}const filePath = path.join(this.outputFilePath, "..", file.path);const fileContent = fs.readFileSync(filePath).toString();let minifiedContent;try {switch (file.extension) {case "scss":case "tsx":case "ts":case "json":case "js":case "css":minifiedContent = this.customMinify(fileContent);break;case "py":minifiedContent = fileContent; // No minification for Python filesbreak;case "html":case "ejs":case "pug":minifiedContent = htmlMinifier(fileContent, { removeComments: true, collapseWhitespace: true });break;case "xaml":case "csproj":minifiedContent = this.minifyXAML(fileContent);break;case "cs":minifiedContent = this.minifyCSharpCode(fileContent);break;case "php":case "phtml":minifiedContent = this.minifyPHP(fileContent);break;case "twig":minifiedContent = this.customMinify(fileContent);break;case "blade.php":minifiedContent = this.minifyPHP(fileContent);break;default:throw new Error("Unsupported file format");}const openTag = `<"file: ${file.path}">`;const closeTag = `</"file: ${file.path}">`;fs.appendFileSync(this.outputFilePath, `${openTag}${minifiedContent}${closeTag}\n\n`);} catch (error) {const errorMessage = `Error minifying ${file.path}: ${error.message}`;this.errors.push(errorMessage);}}));if (this.errors.length > 0) {const errorsText = this.errors.join("\n");fs.appendFileSync(this.outputFilePath, `<"file: error.txt">${errorsText}</"file: error.txt">\n\n`);}}}module.exports = Minifier;</"file: src\minifier.js">

<"file: src\extension.js">const vscode = require("vscode");const { registerCommands } = require("./commands");function activate(context) {registerCommands(context);}function deactivate() {}module.exports = {activate,deactivate};</"file: src\extension.js">

<"file: extension.js">const fs = require("fs");const path = require("path");const vscode = require("vscode");const htmlMinifier = require("html-minifier").minify;const JavaScriptObfuscator = require("javascript-obfuscator");class Minifier {constructor(files, outputFilePath) {this.files = files;this.outputFilePath = outputFilePath;this.errors = [];}async obfuscateJsFiles(filesToObfuscate) {const obfuscationResults = [];for (const file of filesToObfuscate) {const filePath = path.join(this.outputFilePath, "..", file.path);try {const fileContent = fs.readFileSync(filePath, "utf-8");const obfuscatedCode = JavaScriptObfuscator.obfuscate(fileContent);fs.writeFileSync(filePath, obfuscatedCode.getObfuscatedCode());obfuscationResults.push(`<"file: ${file.path}">Successfully obfuscated</"file: ${file.path}">`);} catch (error) {obfuscationResults.push(`<"file: ${file.path}">Couldn't be obfuscated: ${error.message}</"file: ${file.path}">`);}}fs.writeFileSync(path.join(this.outputFilePath, "..", "obfuscated.txt"), obfuscationResults.join("\n"));}shouldIgnoreFile(fileName, ignoreList) {return ignoreList.some((ignoreItem) => fileName.endsWith(ignoreItem));}customMinify(content) {return content.split("\n").map((line) => line.trim()).join("");}minifyXAML(content) {return content.replace(/\s*\n\s*/g, "").replace(/\s*\>\s*/g, ">").replace(/\s*\</g, "<").replace(/\s+/g, " ");}minifyCSharpCode(content) {return content.replace(/\/\/.*/g, "").replace(/\/\*[\s\S]*?\*\//g, "").replace(/\n/g, "").replace(/\s+/g, " ").replace(/\s*([;,:{}()])\s*/g, "$1");}minifyPHP(content) {// Remove commentscontent = content.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');// Remove whitespacecontent = content.replace(/\s+/g, ' ');// Remove whitespace around PHP tagscontent = content.replace(/\s*<\?php\s*/g, '<?php ');content = content.replace(/\s*\?>\s*/g, '?>');return content;}async minifyFiles() {this.files.sort((a, b) => b.modifiedTime - a.modifiedTime);if (fs.existsSync(this.outputFilePath)) {fs.unlinkSync(this.outputFilePath);}await Promise.all(this.files.map(async (file) => {if (this.shouldIgnoreFile(file.name, ["package-lock.json", "dist", "obj", "bin", ".vscode", ".png", ".jpg", ".sample", ".lock", ".md", ".babelrc", ".vsix", ".vscodeignore"])) {return;}const filePath = path.join(this.outputFilePath, "..", file.path);const fileContent = fs.readFileSync(filePath).toString();let minifiedContent;try {switch (file.extension) {case "scss":case "tsx":case "ts":case "json":case "js":case "css":minifiedContent = this.customMinify(fileContent);break;case "py":minifiedContent = fileContent; // No minification for Python filesbreak;case "html":case "ejs":case "pug":minifiedContent = htmlMinifier(fileContent, { removeComments: true, collapseWhitespace: true });break;case "xaml":case "csproj":minifiedContent = this.minifyXAML(fileContent);break;case "cs":minifiedContent = this.minifyCSharpCode(fileContent);break;case "php":case "phtml":minifiedContent = this.minifyPHP(fileContent);break;case "twig":minifiedContent = this.customMinify(fileContent);break;case "blade.php":minifiedContent = this.minifyPHP(fileContent);break;default:throw new Error("Unsupported file format");}const openTag = `<"file: ${file.path}">`;const closeTag = `</"file: ${file.path}">`;fs.appendFileSync(this.outputFilePath, `${openTag}${minifiedContent}${closeTag}\n\n`);} catch (error) {const errorMessage = `Error minifying ${file.path}: ${error.message}`;this.errors.push(errorMessage);}}));if (this.errors.length > 0) {const errorsText = this.errors.join("\n");fs.appendFileSync(this.outputFilePath, `<"file: error.txt">${errorsText}</"file: error.txt">\n\n`);}}}function getFiles(rootPath, currentPath, ignoreList, ignoreDotFiles, ignoreMinFiles) {const files = [];const directoryItems = fs.readdirSync(currentPath);ignoreList = ignoreList.concat(["package-lock.json", "dist", "obj", "bin", ".vscode"]);for (const itemName of directoryItems) {const itemPath = path.join(currentPath, itemName);const relativePath = path.relative(rootPath, itemPath);const itemExtension = path.extname(itemName);if (ignoreList.includes(itemName) || ignoreList.includes(relativePath) || ignoreList.includes(itemExtension)) {continue;}const itemStat = fs.statSync(itemPath);if (itemStat.isDirectory()) {if (itemName.startsWith("env_") || itemName === "node_modules" || itemName === ".git" || itemName === "vendor") {continue;}files.push(...getFiles(rootPath, itemPath, ignoreList, ignoreDotFiles, ignoreMinFiles));} else if (itemStat.isFile()) {if ((ignoreDotFiles && itemName.startsWith(".")) || (ignoreMinFiles && (itemExtension === ".min.js" || itemExtension === ".min.css"))) {continue;}let extension = itemExtension.substring(1);if (itemName.endsWith('.blade.php')) {extension = 'blade.php';}files.push({ path: relativePath, name: itemName, extension: extension, modifiedTime: itemStat.mtime });}}return files;}const minifyCommand = vscode.commands.registerCommand("extension.minifyFiles", async () => {const e = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : (await vscode.window.showOpenDialog({canSelectFiles: false,canSelectFolders: true,canSelectMany: false,openLabel: "Select Folder"}))[0];if (!e) return;const i = await vscode.window.showQuickPick([{ label: "Ignore files starting by . (dot)?", value: "dot" },{ label: 'Ignore files ending in "min.css" and "min.js"?', value: "min", picked: true },{ label: "Ignore any other file or folder?", value: "other" }], {canPickMany: true,placeHolder: "Select options to ignore (use checkboxes)"});const t = i ? i.some(e => "dot" === e.value) : false,s = i ? i.some(e => "other" === e.value) : false,n = i ? i.some(e => "min" === e.value) : false;let o = [];if (s) {const e = await vscode.window.showInputBox({prompt: "Enter the file or folder names or extensions to ignore, separated by commas (e.g., .json, .txt)"});if (e) {o = e.split(",").map(e => e.trim()).filter(e => e);}}const r = e.fsPath,a = path.join(r, ".minifiedCodes.chatgpt"),c = getFiles(r, r, o, t, n),l = new Minifier(c, a);await l.minifyFiles();const h = await vscode.workspace.openTextDocument(a);await vscode.window.showTextDocument(h, vscode.ViewColumn.Active);const obfuscationOption = await vscode.window.showQuickPick([{ label: "Obfuscate current JS file", value: "current" },{ label: "Obfuscate all JS in the workspace", value: "all" },],{ placeHolder: "Select an obfuscation option" });const jsFiles = c.filter((file) => file.extension === "js");if (obfuscationOption && obfuscationOption.value) {if (obfuscationOption.value === "current") {const activeTextEditor = vscode.window.activeTextEditor;if (activeTextEditor) {const activeDocument = activeTextEditor.document;const activeFile = jsFiles.find((file) => file.path === path.relative(r, activeDocument.uri.fsPath));if (activeFile) {await l.obfuscateJsFiles([activeFile]);}}} else if (obfuscationOption.value === "all") {await l.obfuscateJsFiles(jsFiles);}}});const obfuscateCurrentJSFile = vscode.commands.registerCommand("extension.obfuscateCurrentJSFile", async () => {const e = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : (await vscode.window.showOpenDialog({canSelectFiles: false,canSelectFolders: true,canSelectMany: false,openLabel: "Select Folder"}))[0];if (!e) return;const r = e.fsPath,a = path.join(r, ".minifiedCodes.chatgpt"),c = getFiles(r, r, [], false, false),l = new Minifier(c, a);const activeTextEditor = vscode.window.activeTextEditor;if (activeTextEditor) {const activeDocument = activeTextEditor.document;const activeFile = c.find((file) => file.path === path.relative(r, activeDocument.uri.fsPath) && file.extension === "js");if (activeFile) {await l.obfuscateJsFiles([activeFile]);}}});const obfuscateAllJSInWorkspace = vscode.commands.registerCommand("extension.obfuscateAllJSInWorkspace", async () => {const e = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri : (await vscode.window.showOpenDialog({canSelectFiles: false,canSelectFolders: true,canSelectMany: false,openLabel: "Select Folder"}))[0];if (!e) return;const r = e.fsPath,a = path.join(r, ".minifiedCodes.chatgpt"),c = getFiles(r, r, [], false, false),l = new Minifier(c, a);const jsFiles = c.filter((file) => file.extension === "js");await l.obfuscateJsFiles(jsFiles);});const minifySelectedCommand = vscode.commands.registerCommand("extension.minifySelected", async (uri, uris) => {let selectedUris = uris;// If no uris are provided (single selection), use the single uriif (!selectedUris) {selectedUris = uri ? [uri] : [];}// If still no uris, show an errorif (selectedUris.length === 0) {vscode.window.showErrorMessage("No files or folders selected.");return;}const workspaceFolder = vscode.workspace.getWorkspaceFolder(selectedUris[0]);if (!workspaceFolder) {vscode.window.showErrorMessage("Unable to determine workspace folder.");return;}const rootPath = workspaceFolder.uri.fsPath;const outputPath = path.join(rootPath, ".minifiedCodes.chatgpt");const allFiles = [];for (const selectedUri of selectedUris) {const selectedPath = selectedUri.fsPath;if (fs.statSync(selectedPath).isDirectory()) {allFiles.push(...getFiles(rootPath, selectedPath, [], false, false));} else {const relativePath = path.relative(rootPath, selectedPath);let extension = path.extname(selectedPath).substring(1);if (path.basename(selectedPath).endsWith('.blade.php')) {extension = 'blade.php';}allFiles.push({path: relativePath,name: path.basename(selectedPath),extension: extension,modifiedTime: fs.statSync(selectedPath).mtime});}}const minifier = new Minifier(allFiles, outputPath);await minifier.minifyFiles();const document = await vscode.workspace.openTextDocument(outputPath);await vscode.window.showTextDocument(document, vscode.ViewColumn.Active);vscode.window.showInformationMessage(`Minified ${allFiles.length} files from ${selectedUris.length} selections.`);});function activate(context) {context.subscriptions.push(minifyCommand);context.subscriptions.push(obfuscateCurrentJSFile);context.subscriptions.push(obfuscateAllJSInWorkspace);context.subscriptions.push(minifySelectedCommand);}function deactivate() {}module.exports = {activate,deactivate};</"file: extension.js">

<"file: test\suite\extension.test.js">const assert = require('assert');// You can import and use all API from the 'vscode' module// as well as import your extension to test itconst vscode = require('vscode');// const myExtension = require('../extension');suite('Extension Test Suite', () => {vscode.window.showInformationMessage('Start all tests.');test('Sample test', () => {assert.strictEqual(-1, [1, 2, 3].indexOf(5));assert.strictEqual(-1, [1, 2, 3].indexOf(0));});});</"file: test\suite\extension.test.js">

<"file: test\suite\index.js">const path = require('path');const Mocha = require('mocha');const glob = require('glob');function run() {// Create the mocha testconst mocha = new Mocha({ui: 'tdd',color: true});const testsRoot = path.resolve(__dirname, '..');return new Promise((c, e) => {glob('**/**.test.js', { cwd: testsRoot }, (err, files) => {if (err) {return e(err);}// Add files to the test suitefiles.forEach(f => mocha.addFile(path.resolve(testsRoot, f)));try {// Run the mocha testmocha.run(failures => {if (failures > 0) {e(new Error(`${failures} tests failed.`));} else {c();}});} catch (err) {console.error(err);e(err);}});});}module.exports = {run};</"file: test\suite\index.js">

<"file: test\runTest.js">const path = require('path');const { runTests } = require('@vscode/test-electron');async function main() {try {// The folder containing the Extension Manifest package.json// Passed to `--extensionDevelopmentPath`const extensionDevelopmentPath = path.resolve(__dirname, '../');// The path to the extension test script// Passed to --extensionTestsPathconst extensionTestsPath = path.resolve(__dirname, './suite/index');// Download VS Code, unzip it and run the integration testawait runTests({ extensionDevelopmentPath, extensionTestsPath });} catch (err) {console.error('Failed to run tests', err);process.exit(1);}}main();</"file: test\runTest.js">

<"file: jsconfig.json">{"compilerOptions": {"module": "commonjs","target": "ES2020","checkJs": true,  /* Typecheck .js files. */"lib": ["ES2020"]},"exclude": ["node_modules"]}</"file: jsconfig.json">

<"file: .eslintrc.json">{"env": {"browser": false,"commonjs": true,"es6": true,"node": true,"mocha": true},"parserOptions": {"ecmaVersion": 2018,"ecmaFeatures": {"jsx": true},"sourceType": "module"},"rules": {"no-const-assign": "warn","no-this-before-super": "warn","no-undef": "warn","no-unreachable": "warn","no-unused-vars": "warn","constructor-super": "warn","valid-typeof": "warn"}}</"file: .eslintrc.json">

<"file: error.txt">Error minifying .minifiedCodes.chatgpt: Unsupported file format
Error minifying desktop.ini: Unsupported file format
Error minifying .gitignore: Unsupported file format</"file: error.txt">

